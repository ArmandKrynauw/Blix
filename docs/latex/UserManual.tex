\documentclass[11pt,a4paper]{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      PACKAGES                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}
\usepackage{graphicx} % Allows you to insert figures
\usepackage[export]{adjustbox}
\usepackage{booktabs}
\usepackage{amsmath} % Allows you to do equations
\usepackage{helvet}
\usepackage{hyperref}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[a4paper, total={6.5in, 9.5in}]{geometry} % Formats the paper size, orientation, and margins
\linespread{1.1} % about 1.5 spacing in Word
\setlength{\parindent}{0pt} % no paragraph indents
\setlength{\parskip}{1em} % paragraphs separated by one line
\usepackage{listings}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{pmboxdraw}
\usepackage{dirtree}

\hypersetup{
	colorlinks=true,
	urlcolor=cyan,
	linktoc=none,
}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[L,C,R]{}
\fancyfoot[L]{Blix - AI Photo Editor}
\fancyfoot[C]{}
\fancyfoot[R]{\textbf{\thepage}}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0.5pt}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{listings}

% Define TypeScript language style
\lstdefinelanguage{TypeScript}{
  keywords=[1]{class, constructor, let},
  keywordstyle=[1]\bfseries,
  keywords=[2]{string},
  keywordstyle=[2]\color{blue},
  sensitive=true,
  morestring=[b]',
  morestring=[b]"
}


\lstdefinestyle{mystyle}{
backgroundcolor=\color{backcolour},
commentstyle=\color{codegreen},
keywordstyle=\color{magenta},
numberstyle=\tiny\color{codegray},
stringstyle=\color{codepurple},
basicstyle=\ttfamily\footnotesize,
breakatwhitespace=false,
breaklines=true,
keepspaces=true,
numbers=left,
numbersep=5pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2,
}

\lstset{style=mystyle}
\def\code#1{\texttt{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            TITLE PAGE & TABLE OF CONTENTS            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
	\centering
    % \includegraphics[width=0.5\textwidth]{your_logo.png}\par\vspace{1cm}
    {\scshape\LARGE User Manual Specification V1\par}
    \vspace{1.5cm}
    {\huge\bfseries Blix - AI Photo Editor\par}
    \vspace{2.5cm}
    \begin{figure}[h]
        \centering % center the image
        \includegraphics[width=0.5\textwidth]{../pics/blix.png}
    \end{figure}
    \vspace{2.5cm}
    {\Large\itshape The Spanish Inquisition\par}

    \vfill
    {\large \today\par}
\end{titlepage}

\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                MAIN DOCUMENT CONTENT                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}

Introducing Blix: An Advanced AI Photo Editor

Welcome to Blix, an innovative and sophisticated AI-powered photo editing application. Blix sets itself apart by providing users with a seamless editing experience through a powerful and 
intuitive interface, reminiscent of a digital blender. This user manual will guide you through the features and functionalities of Blix, enabling you to harness the full potential of 
this cutting-edge editing tool.

Blix caters to users of all levels, from amateur photographers to seasoned professionals, by streamlining the editing process and eliminating the need 
for extensive knowledge of complex editing software. By presenting a visual graph-based interface, akin to a blender, Blix enables effortless mixing and matching of diverse editing effects.

As a user, you gain access to a vast array of editing possibilities. Whether you wish to apply filters, fine-tune brightness and contrast, or add artistic effects such as vignettes or vintage tones, Blix provides an extensive selection of editing options. Each editing choice is represented as a node within the graph, allowing for seamless connectivity and the creation of custom editing flows tailored to your preferences.

What truly sets Blix apart is its integration of cutting-edge AI technology. Through Blix, you can engage with an AI assistant that enhances your editing journey. 
By sending prompts to the AI, you unlock a world of possibilities. The AI assistant can recommend specific edits, suggest optimal adjustments, or even manipulate the graph on your behalf, 
all based on your unique preferences and the desired outcome.

In summary, Blix is an advanced AI photo editor that empowers users to elevate their photography with ease and finesse. Its intuitive graph-based interface, extensive editing options, 
and integration with an AI assistant create a harmonious environment for realizing your creative vision. This user manual will serve as your comprehensive guide, enabling you 
to navigate the features of Blix and unlock the full potential of your photo editing capabilities.
\pagebreak


\addcontentsline{toc}{section}{Specifications}
\section*{Specifications}

\addcontentsline{toc}{subsection}{Hardware Requirements}
\subsection*{Hardware Requirements}
\begin{itemize}
  \item[\textbullet] \textbf{2 GB RAM}
  \item[\textbullet] \textbf{1.8Ghz }.

\end{itemize}

\addcontentsline{toc}{subsection}{System Requirements}
\subsection*{System Requirements}

Blix is compatible with the following operating systems:
\begin{itemize}
  \item[\textbullet] \textbf{Windows}
  \item[\textbullet] \textbf{Linux }.
  \item[\textbullet] \textbf{MacOS }.
\end{itemize}

 Internet connection is not required, however additional features are available when connected to the internet.

\addcontentsline{toc}{section}{Github Structure and Version Control Strategy}
\section*{Github Version Control Strategy}

\addcontentsline{toc}{subsection}{Branching}
\subsection*{Branching}

The \textbf{Github Flow} branching strategy is used for branching.

The main branch from which all other branches must be created from is the \textit{dev} branch.
Blix operates with feature based branching, thus each branch must be created based of what feature
it will be implementing.

As these features are completed or milestones are reached, these branches are merged back into the \textit{dev} branch.
The \textit{dev} branch is then merged into the \textit{main} branch once a release is ready to be deployed.

The nameing convention for branches is as follows:
\begin{itemize}
    \item[\textbullet] Specific features to be implemented must be prefixed with \textit{feature/} : i.e \textit{feature/palette}
    \item[\textbullet] Core structures to be implemented must be prefixed according to their relevance : \hspace{3cm} i.e \textit{backend/graph}
    \item[\textbullet] miscellaneous branches may be named simply accoridng to their purpose : i.e \textit{dev}, \textit{docs}
\end{itemize}

\addcontentsline{toc}{subsection}{Github Version Control Strategy}
\subsubsection*{Github Version Control Strategy}

\textbf{Commits} are handled according to the following rules : 
\begin{itemize}
    \item[\textbullet] Commits must be atomic, i.e they must only contain changes related to a single feature or bug fix.
    \item[\textbullet] Commits must be in the present tense, to desbribe what the commit does, not what it did.
\end{itemize}

\textbf{Pull requests} are handled according to the following rules : 
\begin{itemize}
    \item[\textbullet] At least one team member other then the iniatator must review the pull request before it is merged.
    \item[\textbullet] The pull request must be linked to an issue.
    \item[\textbullet] The pull request must be linked to a milestone.
    \item[\textbullet] The pull request must pass all automatic tests.
\end{itemize}


\textbf{Issues} are handled according to the following rules : 
\begin{itemize}
    \item[\textbullet] Issues must be atomic, i.e they must only contain changes related to a single feature or bug fix.
    \item[\textbullet] Issues must describe where the problem is, what the problem is, and how to reproduce the problem.
\end{itemize}

\textbf{Merges conflicts} are handled according to the following rules : 
\begin{itemize}
    \item[\textbullet] The person who created the pull request must ensure that the merge conflicts are resolved.
    \item[\textbullet] The relevant developers must be notified of the merge conflict and resolution.
\end{itemize}


\addcontentsline{toc}{section}{Coding Conventions}
\section*{Coding Conventions}

\addcontentsline{toc}{subsection}{Function conventions}
\subsubsection*{Function conventions}

\begin{itemize}
    \item[\textbullet] Function names are to be in camel case, with the first letter being lowercase and the first letter of each subsequent word being uppercase.
    \item[\textbullet] The function names must be descriptive of what the function does.
    \item[\textbullet] The function names must be in the present tense, to describe what the function does, not what it did.
    \item[\textbullet] The function names must not be abbreviated.
    \item[\textbullet] Parameters are formatted according to prettier standards such that each parameter is on a new line.
    \item[\textbullet] Parameters are to be named according to their purpose, not their type.
    \item[\textbullet] Optional parameters are to be at the very end of the parameter list.
\end{itemize}

Example : 

\begin{lstlisting}[language=TypeScript]
  public addSlider(
    label: string,
    min: number,
    max: number,
    step: number,
    defautlVal: number
  ): NodeUIBuilder {
    this.node.addSlider(label, min, max, step, defautlVal);
    return this;
  }

\end{lstlisting}

\addcontentsline{toc}{subsection}{Variable conventions}
\subsubsection*{Variable Conventions}

\begin{itemize}
    \item[\textbullet] Variable names are to be in camel case, as described in the function conventions.
    \item[\textbullet] Variable names must be descriptive of what the variable should do.
    \item[\textbullet] const is preferred over var and let.
    \item[\textbullet] Variables must never be of type any, unless absolutely neccesary.
    \item[\textbullet] Global variables are discouraged, and should be avoided.
    \item[\textbullet] Variables must be declared with the lowest possible scope. 
\end{itemize}

Example :

\begin{lstlisting}[language=TypeScript]
  private signature: string,
  private name: string,
  private plugin: string,
  private title: string,
  private description: string,
  private icon: string,
  private readonly inputs: InputAnchorInstance[],
  private readonly outputs: OutputAnchorInstance[]
\end{lstlisting}

\addcontentsline{toc}{subsection}{Layout conventions}
\subsubsection*{Layout conventions}

\begin{itemize}
    \item[\textbullet] Code blocks must start with a "\{" on the same line as the declaration and end with a "\}" on a new line.
    \item[\textbullet] Each declaration and statement must be on a new line.
\end{itemize}

Example :

\begin{lstlisting}[language=TypeScript]
    public instantiate(plugin: string, name: string): NodeBuilder {
        this.nodeBuilder.instantiate(plugin, name);
        return this.nodeBuilder;
      }
\end{lstlisting}


\addcontentsline{toc}{subsection}{General Coding conventions}
\subsubsection*{General Coding Conventions}

\begin{itemize}
    \item[\textbullet] All code must be formatted according to prettier standards.
    \item[\textbullet] All code must be linted according to eslint standards.
    \item[\textbullet] All code must be typed according to typescript standards.
    % \item[\textbullet] All code must be documented according to jsdoc standards.What are we gonna use for documentation again?
    \item[\textbullet] All code must be tested according to jest standards.
\end{itemize}

Example :

\begin{lstlisting}[language=TypeScript]
private nodesToJSONObject(): NodeToJSON[] {
    const json: NodeToJSON[] = [];
    for (const node in this.nodes) {
      if (!this.nodes.hasOwnProperty(node)) continue;
      json.push(this.nodes[node].toJSONObject());
    }
    return json;
  }
\end{lstlisting}

\addcontentsline{toc}{subsection}{Formatting tools}
\subsubsection*{Formatting tools}

Blix makes use of the following formatting tools to ensure standardization of code and to enforce the coding conventions : 
\begin{itemize}
    \item[\textbullet] \textbf{Prettier} : Prettier is an opinionated code formatter. It enforces a consistent style by parsing
    your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.
    \item[\textbullet] \textbf{eslint} : Eslint is a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code, 
    with the goal of making code more consistent and avoiding bugs.
\end{itemize}

There are a sizeable number of rules that are enforced by these tools, and they are not all listed here. 
For a full list of rules enforced by these tools, please refer to the \textit{.eslintrc.js} and \textit{.prettierrc.js} files in the 
root directory of the project.

In summary these tools are configured to enforce the conventions described above, and to ensure that the code is formatted in a consistent manner.

\pagebreak

\end{document}